import numpy as np
import numpy.typing as npt
from scipy.sparse.linalg import eigs

from rsnn.constants import REFRACTORY_RESET


def compute_phi(
    f_sources: npt.NDArray[np.int64],
    f_times: npt.NDArray[np.float64],
    c_sources: npt.NDArray[np.int64],
    c_weights: npt.NDArray[np.float64],
    c_delays: npt.NDArray[np.float64],
    period: float,
) -> npt.NDArray[np.float64]:
    """Compute the largest eigenvalue of the deflated period-to-period jitter propagation matrix Phi.

    Args:
        f_sources (npt.NDArray[np.int64]): The indices of the neurons producing the firing events, with shape (M,).
        f_times (npt.NDArray[np.float64]): The times of the firing events, with shape (M,).
        c_sources (npt.NDArray[np.int64]): The indices of the neurons at the source of the connections, with shape (L, K).
        c_weights (npt.NDArray[np.float64]): The weights of the connections, with shape (L, K).
        c_delays (npt.NDArray[np.float64]): The delays of the connections, with shape (L, K).
        period (float): The period of the network dynamics.

    Returns:
        npt.NDArray[np.float64]: The largest eigenvalue of the deflated period-to-period jitter propagation matrix Phi.
    """

    M = f_times.size

    # Compute the indices that sort the firing times and create sorted views
    ids = np.argsort(f_times)
    f_sources = f_sources[ids]
    f_times = f_times[ids]

    # Compute the deflated period-to-period jitter propagation matrix Phi
    Phi = np.identity(M)
    for m in range(M):
        f_source = f_sources[m]  # neuron index producing the m-th spike

        # Views on the connections to the neuron producing the m-th spike
        sources = c_sources[f_source]
        weights = c_weights[f_source]
        delays = c_delays[f_source]

        # Get the previous spike generated by the same neuron
        f_time = f_times[m]
        
        i = 1
        while f_sources[(m - i) % M] != f_sources[m]:
            i += 1

        prev_f_time = f_times[(m - i) % M] - period * np.floor_divide(
            f_times[(m - i) % M] - f_time + period, period
        )  # Adjust for periodicity, so that f_time - period <= prev_f_time < f_time

        am = np.zeros(M)
        am[(m - i) % M] -= REFRACTORY_RESET * np.exp(
            -(f_time - prev_f_time)
        ) # Refractoriness contribution to the slope at the m-th spike

        for mi in range(M):
            # Compute the contribution of the mi-th spike to the potential slope at the m-th spike
            select_from = sources == f_sources[mi]
            in_weights = weights[select_from]
            in_f_times = (
                f_times[mi]
                + delays[select_from]
                - period
                * np.floor_divide(
                    f_times[mi] + delays[select_from] - prev_f_time, period
                )
            )  # Adjust for periodicity, so that prev_f_time <= in_f_times < prev_f_time + period

            am[mi] += np.sum(
                in_weights
                * (1 - (f_time - in_f_times))
                * np.exp(-(f_time - in_f_times)),
                where=in_f_times <= f_time,
            )

        # Normalize the contributions to ensure they sum to 1
        am /= np.sum(am)

        Phi[m] = am @ Phi

    # Deflate the matrix to get rid of the global drift
    Phi -= 1 / M

    # Compute the spectral radius of the deflated matrix
    return np.abs(eigs(Phi, k=1, which="LM", return_eigenvectors=False))
